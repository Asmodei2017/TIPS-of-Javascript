## Особенности и нюансы языка JavaScript

#### Типы данных 

#####  Стандарт ECMAScript определяет 7 типов данных

**5** типов данных являются **ПРИМИТИВАМИ**

  - **Number** (Число)

  - **String** (Строка)

  - **Boolean** (Булев, Логический тип TRUE/FALSE)

  - **Null** (Null, ссылка на пустое, не существующее )

  - **Undefined** (значение НЕ ОПРЕДЕЛЕНО)

**2** сложных **типа**

- **Object** (Объекы/Массивы/Функции/JSON) 

- **Symbol** (ES6 читаем)[http://haa.su/EUG/]

------------


#### При сравнении, JS приводит типы к логическому значению

##### список того, что приведется к `false`

1 **Nan**

2 **null**

3 **undefined**

4 **false**

5  **" " пустая стока**

6   **0**

7  ** -0**

#### При преобразовании к числу


### Вернет   1

**true**   вернет **число 1**

### Вернет   0

**Null**    **число 0**

 **FALSE** **число 0**
 
**""** пустая строка **число 0**

###  Вернет NaN 

**строка**   вернет **NaN**

**undefined**   вернет **NaN**

**NaN**   вернет **NaN**

------------
 
#### Нюансы JAVASCRIPT

- При сложении со строкой будет всегда строка. EX: ` 5 + '7' = '57'`
 
- строки сравниваются == по номеру индекса `UNICODа`

- Оператор **&&**  выполняется слева направо и должны быть **ВСЕ  TRUE** , если хоть один будет `false` то вернет `false`

- Оператор  **&&** возвращает **ПЕРВЫЙ FALSE** , а если **все TRUE** – то **последнее значение**.


- Оператор **|| ** вернет **TRUE**  если хотябы **одно из условий будет TRUE**

- Оператор || возвращает **ПЕРВЫЙ** **TRUE** , а если **все FALSE – то последнее значение.**

- **приоритет у && выше** , чем у || поэтому && будет выполняться первым, затем слева направо 

- Одинаковые массивы **НЕ БУДУТ** **===** равны друг другу так как они хранятся **в разных ячейках памяти**

- часть строки нельзя изменить, можно поменять на новую

- **НАСТОЯЩИЕ ЧИСЛА** - это `целое` и `дробное` число (0-9, 2.5) и `infinity`

- **0.1 + 0.2 == 0.3 ** ВЕРНЕТ **FALSE**  пояснение (https://is.gd/Lpz4vq) 

- **typeof null**  вернет  **Object**

- при **математической орерации** если **одно из чисел будет Nan**, то **будет Nan**

- при **математической операции** кроме **СЛОЖЕНИЯ**, **СТРОКА** будет преобразована к **ЧИСЛУ**

- **.tofixed()** возвращает СТРОКУ

#### Другие странности

- null == undefined -=>  true

- null === undefined -=>  true

- null > 0 -=> false

- null == 0 -=> false

- null >= 0 -=> true
  
- `typeOf NaN` -=> `"number"`

- `9999999999999999` -=> `10000000000000000`

- `9 + "1"` -=> `"91"`

- `91 - "1"` -=> `90`

- `0.5 + 0.1 == 0.6` -=> `true`

- `0.1 + 0.2 == 0.3` -=> `false`

- `Math.max()` -=> `-Infinity`

- `Math.min()` -=> `Infinity`

- `[] == 0` -=> `true`

- `[] == []` -=> `false`

- `[] + []` -=> `" "`

- `[] + {}` -=> `" [object Object] "`

- `{} + []` -=> `0`

- `true + true + true === 3` -=> `true`

- `true-true` -=> `0`

- `true == 1` -=> `true`

- `true === 1` -=> `false`

- `(!+[]+[]+![]).length` -=> `9`

## Стрелочные функции

- объявляются и назначаются ТОЛЬКО переменным FunctionExpression

- если параметр 1, то можно передавать без скобок

- если в блоке кода одна команда, то можно писать без фигурных скобок

- если параметров нет, то обязательно должны быть пустые круглые скобки

- нет локальной переменной arguments содержащей все аргументы

- если необходимо собрать все аргументы в коллекцию используйте опертор rest.

- this в использовании внутри тела функции ВСЕГДА будет обращаться к глобальному контексту (ducument)

- НЕЛЬЗЯ использовать как КОНСТРУКТОР 

- НЕ МОЖЕМ использовать такие методы как call() , bind(), apply() из-за того что стрелочная функция автоматически берет внешний контекст

## DEFER ASYNC PRELOAD

Атрибуты defer и async были введены, чтобы дать разработчикам возможность рассказать браузеру, какие скрипты обрабатывать асинхронно.

Оба атрибута сообщают браузеру, что он может продолжить разбор HTML при загрузке сценария «в фоновом режиме», а затем выполнить скрипт после его загрузки. Таким образом, загрузка скриптов не блокирует конструкцию DOM и рендеринг страниц. Результат: пользователь может видеть страницу до того, как все сценарии завершили загрузку.

Разница между ними - это тот момент, когда загруженые скрипты начинают выполняться.

**DEFER**

- **загружает** скрипт **паралельно**

- выполняется **ПОСЛЕ ОТРИСОВКИ DOM**

- **СОБЛЮДАЕТ** правила очередности выполнеиня скриптов

- Выполнение **defer** скриптов начинается **после завершения парсинга**, но **перед событием DOMContentLoaded**. 
- Это гарантирует, что скрипты **будут выполняться в том порядке, в котором они отображаются в HTML, и не будут блокировать синтаксический анализатор**.

**ASYNC**

- загружается **паралельно** загрузке dom

- как только загрузился **СРАЗУ** выполняется

- может **блокировать** отрисовку **dom**

- если есть неколько скриптов с async то они все загружаются -одновременно, первый будет тот который выполнится раньше, **ИГНОРИРУЕТ** очередность кода

- async выполняется **при первой возможности после завершения загрузки** и **перед событием загрузки окна**. 
- Это означает, что **возможно скрипты не выполняются в том порядке, в котором они отображаются в HTML**. 
- Это также означает, что они **могут прервать создание DOM**.

Где бы они ни были указаны, асинхронные скрипты загружаются с низким приоритетом. Они часто загружаются после всех других скриптов, не блокируя создание DOM. Однако, если async скрипт завершает загрузку раньше, его выполнение может блокировать создание DOM и все синхронные скрипты, которые впоследствии завершают загрузку.

**PRELOAD**
- Для важных ресурсов, от которых зависит например CSS или другое важное отображение можно использовать `<link rel="preload">`  для того чтобы **сообщить браузеру** о том, что вы хотите **загрузить эти ресурсы как можно быстрее**.
 ```javascript
<link rel="preload" href="very_important.js" as="script">
```
- Можно указать к загрузке почти что угодно, и **атрибут as укажет браузеру что тот будет загружать**. 
- Некоторые из возможных значений: **script, style, image, font, audio, video.**

## Отличия промиса и callback-функции:

- Коллбэки это функции, обещания это объекты
- Коллбэки передаются в качестве аргументов, обещания возвращаются
- Коллбэки обрабатывают успешное или неуспешное завершение, обещания ничего не обрабатывают
- Коллбэки могут обрабатывать несколько событий, обещания связаны только с одним событием
